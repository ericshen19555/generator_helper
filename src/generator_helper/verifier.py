# -*- coding: utf-8 -*-
"""
verifier.py

Provides a factory function to create a verifier. The verifier checks if a
generated test case correctly distinguishes between different provided solutions
based on expected outcomes (Accepted, Wrong Answer, Time Limit Exceeded,
Runtime Error).
"""

from typing import Callable, NoReturn, Literal, Optional, Union
from operator import eq

from func_timeout import func_set_timeout

from .subtask_gen import assert_testcase, TestcaseInvalidError
from .exceptions import TimeLimitExceededError

# Define type aliases for clarity
Outcome = Literal["AC", "WA"] | type[TimeLimitExceededError] | type[Exception]
ExpectedResults = dict[int, dict[Outcome, list[Callable]]]

# Define constants for expected outcomes
TLE = TimeLimitExceededError
AC: Literal["AC"] = "AC"
WA: Literal["WA"] = "WA"


def _truncate_repr(text: str, max_len: int = 50) -> str:
    """
    Truncates the repr() of a string if it exceeds a maximum length.

    If the length of the input string `text` is greater than `max_len`,
    its representation is truncated to `max_len` characters, and '...'
    is appended. Otherwise, the full repr() of the string is returned.

    Args:
        text: The input string to represent and potentially truncate.
        max_len: The maximum allowed length for the representation before
                 truncation occurs. Defaults to 50.

    Returns:
        A string containing the potentially truncated representation.
    """
    # Get the representation of the text
    represented_text = repr(text)
    # Check if the representation length exceeds the limit
    if len(represented_text) > max_len:
        # Truncate and add ellipsis
        truncated_original = text[:max_len - 3] + "..."
        return repr(truncated_original)
    else:
        # Representation is within the limit, return as is
        return represented_text


def verifier_factory(expected: ExpectedResults,
                     *, equal: Optional[Callable] = eq, timeout: float = 1.0):
    """
    Factory function to create a tailored verifier function.

    The created verifier takes a test case index and the test case input string.
    It runs various solutions (provided in the 'expected' dictionary) against
    this input and checks if their outcomes match the expectations.

    Args:
        expected: A dictionary mapping test case indices (int) to another
                  dictionary. This inner dictionary maps expected outcomes
                  (AC, WA, TLE class, or other Exception classes) to lists
                  of solution functions that should produce that outcome.
                  Solution functions are expected to be decorated with @override_io.
        equal: A function used to compare the outputs of solutions. Defaults to
               operator.eq. Useful for custom comparisons (e.g., float tolerance).
        timeout: The time limit in seconds applied to each solution execution.

    Returns:
        A verifier function. This function takes (testcase_index, testcase_string)
        and returns the correct answer string (from the first AC solution) if
        the verification is successful. It raises TestcaseInvalidError if the
        test case fails to meet the expected differentiation criteria, or other
        errors for configuration issues.

    Raises:
        ValueError: If no AC solution is provided for a configured test case index.
        TypeError: If an expected outcome key is not AC, WA, or an Exception type.
        TestcaseInvalidError: If a solution does not behave as expected for the given
                              test case (e.g., an expected WA solution gives the same
                              output as AC, or an expected RE solution runs successfully).
    """
    def verifier(testcase_index: int, testcase) -> Union[str, NotImplemented, NoReturn]:
        """
        The verifier function generated by the factory.

        Checks a given test case against the configured expected outcomes for
        the specified test case index.

        Args:
            testcase_index: The index of the test case being verified.
            testcase: The string input for the test case.

        Returns:
            The correct answer string (output of the first AC solution) if
            verification succeeds.

        Raises:
            ValueError: If AC solution is missing in the configuration.
            TypeError: If the configuration contains invalid outcome types.
            TestcaseInvalidError: If any solution behaves unexpectedly.
            NotImplementedError: If testcase_index is not found in 'expected' dict.
                                 (Consider changing this to KeyError or similar).
        """
        # Retrieve the expected outcomes for this specific test case index
        if (res_to_sols := expected.get(testcase_index)) is None:
            # Configuration for this index not found.
            return NotImplemented
            # raise NotImplementedError(f"Verifier configuration not found for testcase_index: {testcase_index}")

        # Check if at least one Accepted solution is provided
        if not (ac_sols := res_to_sols.get(AC, None)):
            raise ValueError(f"Verifier configuration for testcase_index {testcase_index} "
                             f"must include at least one AC solution.")

        # Create a decorator to apply the time limit to solution calls
        time_limit_dec = func_set_timeout(timeout)

        # --- Step 1: Verify AC solutions ---
        # Apply time limit to all AC solutions
        ac_sols = map(time_limit_dec, ac_sols)

        # Run the first AC solution to get the reference answer
        first_ac_sol = next(ac_sols)
        try:
            # Run the decorated solution, passing the testcase input
            # override_io decorator handles stdin/stdout and returns (ret, output)
            _, reference_answer_output = first_ac_sol(testcase=testcase, testcase_index=testcase_index)
        except TimeLimitExceededError as e:
            # The reference AC solution timed out, this testcase is invalid
            raise TestcaseInvalidError(f"Reference AC solution '{first_ac_sol.__name__}' "
                                       f"timed out (limit: {timeout}s).") from e
        except TestcaseInvalidError as e:
            # The reference AC solution raised TestcaseInvalidError
            raise TestcaseInvalidError(f"Reference AC solution '{first_ac_sol.__name__}' "
                                       f"raised TestcaseInvalidError:\n\t{e!r}") from e
        except Exception as e:
            # The reference AC solution had an unexpected runtime error
            raise RuntimeError(f"Reference AC solution '{first_ac_sol.__name__}' "
                               f"raised an unexpected error:\n\t{e!r}") from e

        # Verify that all other AC solutions produce the same output
        for other_ac_sol in ac_sols:  # Start from the second AC sol
            try:
                _, other_output = other_ac_sol(testcase=testcase, testcase_index=testcase_index)
                # Use the custom assertion to check if outputs match
                assert_testcase(
                    equal(reference_answer_output, other_output),
                    f"AC solutions disagreement: Output of '{first_ac_sol.__name__}' != '{other_ac_sol.__name__}'. "
                    f"Expected same output {_truncate_repr(reference_answer_output)}, got {_truncate_repr(other_output)}"
                )
            except TimeLimitExceededError as e:
                raise TestcaseInvalidError(f"Additional AC solution '{other_ac_sol.__name__}' "
                                           f"timed out (limit: {timeout}s). Expected AC.") from e
            except Exception as e:
                raise TestcaseInvalidError(f"Additional AC solution '{other_ac_sol.__name__}' "
                                           f"raised an unexpected error:\n\t{e!r}. Expected AC.") from e

        # --- Step 2: Verify non-AC solutions ---
        for expected_outcome, sols in res_to_sols.items():
            # Skip AC solutions, already handled
            if expected_outcome == AC:
                continue

            # Apply time limit decorator to these solutions
            sols = map(time_limit_dec, sols)

            if expected_outcome == WA:
                # Verify Wrong Answer solutions
                for wa_sol in sols:
                    try:
                        _, wa_output = wa_sol(testcase=testcase, testcase_index=testcase_index)
                        # Assert that the WA output is NOT equal to the reference AC output
                        assert_testcase(
                            not equal(reference_answer_output, wa_output),
                            f"Expected WA, but solution '{wa_sol.__name__}' produced the same output "
                            f"as AC solution '{first_ac_sol.__name__}'. Output: {_truncate_repr(wa_output)}",
                        )
                    except TimeLimitExceededError as e:
                        raise TestcaseInvalidError(
                            f"Expected WA solution '{wa_sol.__name__}' "
                            f"timed out (limit: {timeout}s). Expected WA, not TLE.") from e
                    except Exception as e:
                        raise TestcaseInvalidError(
                            f"Expected WA solution '{wa_sol.__name__}' "
                            f"raised an unexpected error:\n\t{e!r}. Expected WA.") from e

            elif (expected_outcome is TimeLimitExceededError
                  or (isinstance(expected_outcome, type) and issubclass(expected_outcome, Exception))):
                # Verify solutions expected to raise specific Exceptions (including TLE)
                ExpectedExceptionType = expected_outcome  # e.g., ZeroDivisionError or TimeLimitExceededError

                for err_sol in sols:
                    try:
                        # Run the solution, expecting an exception
                        ret_val, output = err_sol(testcase=testcase, testcase_index=testcase_index)
                        # If it completes without error, it's invalid
                        raise TestcaseInvalidError(
                            f"Solution '{err_sol.__name__}' completed successfully "
                            f"(returned {ret_val!r}, output {_truncate_repr(output)}) "
                            f"but was expected to raise {ExpectedExceptionType.__name__}."
                        )
                    except TimeLimitExceededError as e:
                        # The solution timed out. Check if TLE was the expected outcome.
                        # Note: TLE is defined as TimeLimitExceededError in exceptions.py
                        assert_testcase(
                            isinstance(e, ExpectedExceptionType),  # Check if the caught exception is the expected type
                            f"Solution '{err_sol.__name__}' raised {type(e).__name__} (TLE), "
                            f"but expected {ExpectedExceptionType.__name__}.",
                            from_=e  # Chain the exception
                        )
                        # If TLE was expected, this assertion passes, loop continues
                    except Exception as e:
                        # An exception other than TLE occurred. Check if it's the expected one.
                        assert_testcase(
                            isinstance(e, ExpectedExceptionType),  # Check if the caught exception is the expected type
                            f"Solution '{err_sol.__name__}' raised {type(e).__name__} ({e!r}), "
                            f"but expected {ExpectedExceptionType.__name__}.",
                            from_=e  # Chain the exception
                        )
                        # If it was the expected exception, this passes, loop continues
            else:
                # Configuration error: outcome key is not AC, WA, or an Exception type
                raise TypeError(
                    f"Invalid expected outcome type in configuration: {expected_outcome!r}. "
                    f"Must be 'AC', 'WA', or an Exception subclass.")

        # If all checks passed, the test case is valid and distinguishes solutions correctly.
        # Return the reference answer obtained from the first AC solution.
        return reference_answer_output

    return verifier
